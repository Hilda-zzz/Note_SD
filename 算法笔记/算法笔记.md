# 算法笔记

## 数组类

### 力扣704. 二分查找

2023-12-19

**思路1**

1. [left,right]思路
2. 定义初始的left,right值
3. while(l<=r)
4. int mid=left+((right-left)/2) （这一操作与 mid=(left+right)/2）相比可以规避某些情况下，left+right超过最大界限
5. if/ else if/ else 改变区间/ 找到时返回mid

```c++
//时间复杂度 O(logn)
class Solution {
public:
    int search(vector<int>& nums, int target) {
    	//1
        int left=0;
        int right=nums.size()-1;
        //2
        while(left<=right)
        {
        	//3
            int mid=left+((right-left)/2);
            //4
            if(nums[mid]<target)
            {
                left=mid+1;
            }
            else if(nums[mid]>target)
            {
                right=mid-1;
            }
            else 
                return mid;
        }
        //5
        return -1;
    }
};
```

**思路2**

1. [left,right) 思路
2. 定义初始left right, left=0 right=nums.size()
3. while(l<r)

### 力扣27.  移除元素

2023.12.20

要求原地移除，空间复杂度为O(1),也就是不使用额外空间，最后返回新数组的size

**思路1**

1. 暴力解法
2. 两个for循环，第一层for找到一样的数值，第二个for将其后面的数向前移动
3. 时间复杂度O(n^2)

**思路2**

1. 双指针法（快慢指针法）（在数组和链表操作中很常见）
2. slowIndex=0
3. for循环中用fastIndex从0遍历到最后
4. 当nums[index]!=val时，两个指针将一起前进
5. 当nums[index]==val时，慢指针指针将被滞留在原有位置
6. 在下一次循环中，若是不等于val,则通过 nums[slowIndex++]=nums[fastIndex],可以使等于val的数组位置被第一个遇见的符合要求的数覆盖
7. 最后返回slowIndex

```c++
//空间O(1)
//时间O(n)
class Solution {
public:
    int removeElement(vector<int>& nums, int val) {
        int slowIndex=0;
        for(int fastIndex=0;fastIndex<nums.size();fastIndex++)
        {
            if(nums[fastIndex]!=val)
            {
                nums[slowIndex]=nums[fastIndex];
                slowIndex++;
            }
        }
        return slowIndex;
    }
};
```

**双指针法（快慢指针法）在数组和链表的操作中是非常常见的，很多考察数组、链表、字符串等操作的面试题，都使用双指针法。**

**思路3**

1. 相向双指针方法

```c++
/**
* 相向双指针方法，基于元素顺序可以改变的题目描述改变了元素相对位置，确保了移动最少元素
* 时间复杂度：O(n)
* 空间复杂度：O(1)
*/
class Solution {
public:
    int removeElement(vector<int>& nums, int val) {
        int leftIndex = 0;
        int rightIndex = nums.size() - 1;
        while (leftIndex <= rightIndex) {
            // 找左边等于val的元素
            while (leftIndex <= rightIndex && nums[leftIndex] != val){
                ++leftIndex;
            }
            // 找右边不等于val的元素
            while (leftIndex <= rightIndex && nums[rightIndex] == val) {
                -- rightIndex;
            }
            // 将右边不等于val的元素覆盖左边等于val的元素
            if (leftIndex < rightIndex) {
                nums[leftIndex++] = nums[rightIndex--];
            }
        }
        return leftIndex;   // leftIndex一定指向了最终数组末尾的下一个元素
    }
};

```

### 力扣209. 长度最小的子数组

2023.12.20

**思路1**

1. 暴力解法
2. 双重循环，第一层循环遍历起点，第二层循环从起点往后叠加，直到大于要求数目，更新子数组长度
3. 时间O(n^2)

**思路2**

1. 滑动窗口:不断的调节子序列的起始位置和终止位置
2. 只用一个for循环，那么这个循环的索引，一定是表示 滑动窗口的终止位置。
3. while 判断是否满足总和大于要求，将窗口起点不断向前移动，并对比之前记录的Len结果更新

```c++
//时间O(n)
//空间O(1)
class Solution {
public:
    int minSubArrayLen(int target, vector<int>& nums) {
        int sum=0;
        int start=0;
        int curLen=0;
        int result=INT32_MAX;
        //用INT32_MAX可以缩短运行时间
        for(int end=0;end<nums.size();end++)
        {
            sum+=nums[end];
            while(sum>=target)
            {
                curLen=end-start+1;             
                if(curLen<=result)
                {
                    result=curLen;
                }
                sum-=nums[start];
                start++;
            }
        }
        if(result<INT32_MAX)
            return result;
        else
            return 0;
    }
};
```

### 力扣977.有序数组的平方

2023.12.21

**思路**

1. 双指针法
2. 需要新开一个result数组
3. while(i<j)
4. 不交换右指针--
5. 交换左指针++
6. 从数组末尾开始赋值

```c++
class Solution {
public:
    vector<int> sortedSquares(vector<int>& nums) {
        vector<int> result(nums.size(), 0);
        int size=nums.size();
        int i=0;
        int j=size-1;
        int k=size-1;
        while(i<=j)
        {
            if(nums[i]*nums[i]>nums[j]*nums[j])
            {
                result[k]=nums[i]*nums[i];
                k--;
                i++;
            }
            else
            {
                result[k]=nums[j]*nums[j];
                k--;
                j--;
            }
        }
        return result;
    }
};
```

### 力扣59. 螺旋矩阵Ⅱ

2023.12.20

**思路1**

1. 循环不变量的原则
2. 左闭右开画圈，左闭右开是“不变量”

```c++
class Solution {
public:
    vector<vector<int>> generateMatrix(int n) {
        vector<vector<int>> res(n,vector<int>(n,0));
        //每循环一个圈的起始位置
        int startx=0;
        int starty=0;
        int loop=n/2;//循环几圈
        int mid=n/2;//矩阵的中间位置
        int count=1;//用来给每个格赋值
        int offset=1;//每圈都要控制每一条边的长度
        int i,j;
        while(loop--)
        {
            i=startx;
            j=starty;
            //四个for模拟转一圈
            //左到右
            for(j=startx;j<n-offset;j++)
            {
                res[startx][j]=count;
                count++;
            }
            for(i=startx;i<n-offset;i++)
            {
                res[i][j]=count;
                count++;
            }
            for(;j>starty;j--)
            {
                res[i][j]=count++;
            }
            for(;i>startx;i--)
            {
                res[i][j]=count++;
            }

            //第二圈开始时，startx,starty都要加1
            startx++;
            starty++;
            offset+=1; //用于控制长度，注意起点也是再变化的

        } 
        if(n%2==1)
        {
            res[mid][mid]=count;
        }
        return res;
    }
};
```

**思路2**

右下左上，四个方向按顺序走，而且每次一定要走到底就完事了，好神的思路

```c++
class Solution {
public:
    vector<vector<int>> generateMatrix(int n) 
    {
        vector<vector<int>> res(n,vector<int>(n,0));
        int i = 0, j = 0, cur = 2;
        res[0][0] = 1;
        while (cur <= n * n) 
        {
            while (j < n - 1 && res[i][j + 1] == 0) res[i][++j] = cur++; // 右
            while (i < n - 1 && res[i + 1][j] == 0) res[++i][j] = cur++; // 下
            while (j > 0 && res[i][j - 1] == 0) res[i][--j] = cur++; // 左
            while (i > 0 && res[i - 1][j] == 0) res[--i][j] = cur++; // 上
        }
        return res;
    }
};
```

## 链表类

### 力扣203. 移除链表元素

2023.12.25

**思路**

1. 设置虚拟头节点，以便于删除的节点是头节点

```c++
/** 链表节点的定义方法
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* removeElements(ListNode* head, int val) {
        //定义虚拟头节点
        ListNode*dummyHead=new ListNode(0);
        dummyHead->next=head;
        //定义curNode
        ListNode*curNode=dummyHead;
        while(curNode->next!=NULL)
        {
            if(curNode->next->val==val)
            {
                ListNode*temp=new ListNode(0);
                temp=curNode->next;
                curNode->next=curNode->next->next;
                delete temp;
            }
            else{
                curNode=curNode->next;
            }
            
        }
        //返回真正的头节点
        head=dummyHead->next;
        delete dummyHead;
        return head;
    }
};
```

### 力扣707. 设计链表

2023.12.25

```c++
class MyLinkedList {
public:
    struct LinkedNode
    {
        int val;
        LinkedNode*next;
        LinkedNode(int val):val(val),next(nullptr){}
    };
    MyLinkedList() {
        dummyHead=new LinkedNode(0);
        size=0;
    }
    
    int get(int index) {
        if(index>=size||index<0)
        {
            return -1;
        }
        int i=0;
        LinkedNode*curNode=dummyHead->next;
        while(i<index)
        {
            curNode=curNode->next;
            i++;
        }
        return curNode->val;
    }
    
    void addAtHead(int val) {
        LinkedNode*curNode=new LinkedNode(val);
        curNode->next=dummyHead->next;
        dummyHead->next=curNode;
        size++;
    }
    
    void addAtTail(int val) {
        LinkedNode*curNode=dummyHead;
        while(curNode->next!=nullptr)
        {
            curNode=curNode->next;
        }
        LinkedNode*newNode=new LinkedNode(val);
        curNode->next=newNode;
        size++;
    }
    
    void addAtIndex(int index, int val) {
        if(index>size||index<0)
        {
            return;
        }
        int i=0;
        LinkedNode*curNode=dummyHead;
        while(i<index)
        {
            curNode=curNode->next;
            i++;
        }
        LinkedNode*newNode=new LinkedNode(val);
        newNode->next=curNode->next;
        curNode->next=newNode; 
        size++;
    }
    
    void deleteAtIndex(int index) {
        if(index>=size||index<0)
        {
            return ;
        }
        int i=0;
        LinkedNode*curNode=dummyHead;
        while(i<index)
        {
            curNode=curNode->next;
            i++;
        }
        LinkedNode*newNode=curNode->next;
        curNode->next=curNode->next->next;
        delete(newNode);
        size--;
    }
private:
    LinkedNode*dummyHead;
    int size;
};

/**
 * Your MyLinkedList object will be instantiated and called as such:
 * MyLinkedList* obj = new MyLinkedList();
 * int param_1 = obj->get(index);
 * obj->addAtHead(val);
 * obj->addAtTail(val);
 * obj->addAtIndex(index,val);
 * obj->deleteAtIndex(index);
 */
```

### 力扣206. 反转链表

2023.12.27

**思路1**

1. 双指针法
2. cur指向头，pre指向空

**思路2**

1. 递归法

```C++
//1
class Solution {
public:
    ListNode* reverseList(ListNode* head) {
        //保存当前节点的下一个节点
        ListNode*temp;
        ListNode*cur=head;
        ListNode*pre=nullptr;
        while(cur)
        {
            //保存下个节点
            temp=cur->next;
            //反转当前节点的指针
            cur->next=pre;
            //双指针向前平移
            pre=cur;
            cur=temp;
        }
        return pre;
    }
};

//2
class Solution {
public:
    ListNode* reverse(ListNode*cur,ListNode*pre)
    {
        if(cur==nullptr) return pre;
        ListNode*temp=cur->next;
        cur->next=pre;
        return reverse(temp,cur);
    }
    ListNode* reverseList(ListNode* head) {
        return reverse(head,nullptr);
    }
};
```

### 力扣19. 删除链表的倒数第 N 个结点

2023.12.27

**思路**

1. 快慢指针
2. 先把两个指针的间隔错开
3. 然后一直遍历到快指针到尽头为止
4. 下面cur是快指针

***要点总结：涉及到可能会删除头节点的需要使用dummyHead***

```C++
class Solution {
public:
    ListNode* removeNthFromEnd(ListNode* head, int n) {
        ListNode*dummyHead=new ListNode(0,head);
        ListNode*cur=dummyHead;
        ListNode*pre=head;
        ListNode*temp=new ListNode(0);
        int i=0;
        while(i<n)
        {
            cur=cur->next;
            i++;
        }
        temp=dummyHead;
        while(cur->next)
        {
            temp=pre;
            cur=cur->next;
            pre=pre->next;
        }
        temp->next=pre->next;
        delete(pre);
        return dummyHead->next;
        //不使用temp的方法
        //第一次移位循环后让cur=cur->next这样pre最终就会在要删的节点的前一个
        //这时循环while(cur)
    }
};
```

### 面试题 02.07. 链表相交
https://leetcode.cn/problems/intersection-of-two-linked-lists-lcci/
2024.9.16
```C++

```

### 142.环形链表II
https://leetcode.cn/problems/linked-list-cycle-ii/description/

## 哈希表 
### 理论基础



### 242.有效的字母异位词
https://leetcode.cn/problems/valid-anagram/description/

